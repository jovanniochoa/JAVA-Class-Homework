/*
 * 22.5 finds fibonacci numbers using dynamic programming
 * 
 * Dynamic programming is basically solving subproblems to solve the 
 * overall solution.
 * 
 * In this example of fibonacci, we see that recursion is an ineffective solution
 * This can be seen because the sub-problems overlap; thus it's ineffective
 * because we have to redo steps that have already been done.
 * _____________________________________________________________________________________
 * 
 * 22.7 finds efficient algorithm's for finding prime numbers
 * 
 * We notice a starightforward example of using the square root function to check
 * for i being prime
 * 
 * This however is seen to be inefficient because of the time complexity you are using
 * 
 * To solve this, you can use a form of dynamic programming to show how 
 * the code can be simplified and altered to fit an algorithm for better finding
 * the prime numbers
 * 
 * This reduces the time complexity dramatically.
*/